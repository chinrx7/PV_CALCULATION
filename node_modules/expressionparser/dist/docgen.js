"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const index_1 = require("./index");
const generateDocs = (language) => {
    const prefixOps = new Set();
    const infixOps = new Set();
    language.descriptions.forEach((op) => {
        if (op.fix === "infix") {
            infixOps.add(op.op);
        }
        else if (op.fix === "prefix") {
            prefixOps.add(op.op);
        }
    });
    Object.keys(language.INFIX_OPS).forEach((op) => {
        if (!infixOps.has(op)) {
            console.error(op, "Missing from docs (infix)");
        }
    });
    Object.keys(language.PREFIX_OPS).forEach((op) => {
        if (!prefixOps.has(op)) {
            console.error(op, "Missing from docs (prefix)");
        }
    });
    return ("# Language Reference\n" +
        language.descriptions
            .map((op) => {
            const returnVal = op.sig[op.sig.length - 1];
            const args = op.sig.slice(0, op.sig.length - 1);
            let sigDoc;
            if (op.fix === "infix") {
                sigDoc = `(${args[0]} ${op.op} ${args[1]}): ${returnVal}`;
                if (!(op.op in language.INFIX_OPS)) {
                    console.error(op.op, "not in INFIX_OPS");
                }
            }
            else if (op.fix === "prefix") {
                sigDoc = `${op.op}(${args.join(", ")}): ${returnVal}`;
                if (!(op.op in language.PREFIX_OPS)) {
                    console.error(op.op, "not in PREFIX_OPS");
                }
            }
            else {
                sigDoc = `${op.op.replace("...", args[0])}: ${returnVal}`;
            }
            return `
## ${op.op}

\`${sigDoc}\`

${op.text}`;
        })
            .join("\n") +
        "\n");
};
const formulaDocs = generateDocs(index_1.formula((term) => null));
fs_1.writeFile(path_1.resolve(__dirname, "./languages/formula.md"), formulaDocs, (err) => {
    if (err) {
        throw err;
    }
});
//# sourceMappingURL=docgen.js.map